diff --git a/src/main/java/net/wurstclient/serverfinder/GetPlayersScreen.java b/src/main/java/net/wurstclient/serverfinder/GetPlayersScreen.java
new file mode 100644
index 00000000..c62d3849
--- /dev/null
+++ b/src/main/java/net/wurstclient/serverfinder/GetPlayersScreen.java
@@ -0,0 +1,515 @@
+/*
+ * Copyright (c) 2014-2025 Wurst-Imperium and contributors.
+ *
+ * This source code is subject to the terms of the GNU General Public
+ * License, version 3. If a copy of the GPL was not distributed with this
+ * file, You can obtain one at: https://www.gnu.org/licenses/gpl-3.0.txt
+ */
+package net.wurstclient.serverfinder;
+
+import java.io.IOException;
+import java.time.Instant;
+import java.time.ZoneId;
+import java.time.format.DateTimeFormatter;
+import java.time.format.FormatStyle;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+import org.lwjgl.glfw.GLFW;
+
+import net.minecraft.client.gui.Click;
+import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Drawable;
+import net.minecraft.client.gui.screen.Screen;
+import net.minecraft.client.gui.screen.multiplayer.MultiplayerScreen;
+import net.minecraft.client.gui.widget.ButtonWidget;
+import net.minecraft.client.gui.widget.TextFieldWidget;
+import net.minecraft.client.input.KeyInput;
+import net.minecraft.text.Text;
+import net.minecraft.util.Colors;
+import net.wurstclient.serverfinder.api.ServerInfoRequest;
+import net.wurstclient.serverfinder.api.ServerInfoResponse;
+import net.wurstclient.serverfinder.api.WhereisResponse;
+
+public class GetPlayersScreen extends Screen
+{
+	private final MultiplayerScreen prevScreen;
+	private List<WhereisResponse.PlayerServerEntry> servers;
+	private int scroll = 0;
+	private static final int SERVERS_PER_PAGE = 12;
+	
+	// Server info mode
+	private TextFieldWidget serverAddressBox;
+	private ButtonWidget getInfoButton;
+	private GetPlayersState state;
+	private ServerInfoResponse serverInfo;
+	private String lastError;
+	private boolean isServerInfoMode;
+	
+	public GetPlayersScreen(MultiplayerScreen prevScreen,
+		List<WhereisResponse.PlayerServerEntry> servers)
+	{
+		super(Text.literal(
+			servers.isEmpty() ? "Get Server Info" : "Player Server History"));
+		this.prevScreen = prevScreen;
+		this.servers = servers;
+		this.isServerInfoMode = servers.isEmpty();
+	}
+	
+	@Override
+	public void init()
+	{
+		addDrawableChild(
+			ButtonWidget.builder(Text.literal("Back"), b -> close())
+				.dimensions(width / 2 - 100, height - 40, 200, 20).build());
+		
+		if(isServerInfoMode)
+		{
+			// Server info mode - add input field and get info button
+			serverAddressBox = new TextFieldWidget(textRenderer,
+				width / 2 - 100, height / 4 + 34, 200, 20, Text.empty());
+			serverAddressBox.setMaxLength(200);
+			serverAddressBox
+				.setPlaceholder(Text.literal("Enter server address (ip:port)"));
+			addSelectableChild(serverAddressBox);
+			setFocused(serverAddressBox);
+			
+			addDrawableChild(getInfoButton = ButtonWidget
+				.builder(Text.literal("Get Server Info"), b -> getServerInfo())
+				.dimensions(width / 2 - 100, height / 4 + 60, 200, 20).build());
+			getInfoButton.active = false;
+			
+			state = GetPlayersState.NOT_RUNNING;
+		}else
+		{
+			// Player search results mode - add scroll buttons if needed
+			if(servers.size() > SERVERS_PER_PAGE)
+			{
+				addDrawableChild(
+					ButtonWidget.builder(Text.literal("▲ Up"), b -> scrollUp())
+						.dimensions(width / 2 + 110, height / 2 - 60, 60, 20)
+						.build());
+				
+				addDrawableChild(ButtonWidget
+					.builder(Text.literal("▼ Down"), b -> scrollDown())
+					.dimensions(width / 2 + 110, height / 2 + 40, 60, 20)
+					.build());
+			}
+		}
+	}
+	
+	private void scrollUp()
+	{
+		if(scroll > 0)
+			scroll--;
+	}
+	
+	private void scrollDown()
+	{
+		int maxScroll = Math.max(0, servers.size() - SERVERS_PER_PAGE);
+		if(scroll < maxScroll)
+			scroll++;
+	}
+	
+	private void getServerInfo()
+	{
+		if(state != null && state.isRunning())
+		{
+			state = GetPlayersState.CANCELLED;
+			serverAddressBox.active = true;
+			getInfoButton.setMessage(Text.literal("Get Server Info"));
+			return;
+		}
+		
+		String address = serverAddressBox.getText().trim();
+		if(address.isEmpty())
+			return;
+		
+		state = GetPlayersState.SEARCHING;
+		serverAddressBox.active = false;
+		getInfoButton.setMessage(Text.literal("Cancel"));
+		lastError = null;
+		serverInfo = null;
+		
+		// Parse address
+		String[] parts = address.split(":");
+		String ip = parts[0];
+		int port = parts.length > 1 ? parsePort(parts[1]) : 25565;
+		
+		if(port == -1)
+		{
+			state = GetPlayersState.ERROR;
+			lastError = "Invalid port number";
+			serverAddressBox.active = true;
+			getInfoButton.setMessage(Text.literal("Get Server Info"));
+			return;
+		}
+		
+		// Create request asynchronously
+		CompletableFuture.supplyAsync(
+			() -> new ServerInfoRequest(ServerSeekerHttp.getApiKey(), ip, port))
+			.thenCompose(this::executeServerInfoRequest)
+			.thenAccept(this::handleServerInfoResponse)
+			.exceptionally(this::handleServerInfoError);
+	}
+	
+	private int parsePort(String portStr)
+	{
+		try
+		{
+			int port = Integer.parseInt(portStr);
+			return (port > 0 && port <= 65535) ? port : -1;
+		}catch(NumberFormatException e)
+		{
+			return -1;
+		}
+	}
+	
+	private CompletableFuture<ServerInfoResponse> executeServerInfoRequest(
+		ServerInfoRequest request)
+	{
+		return CompletableFuture.supplyAsync(() -> {
+			try
+			{
+				return ServerSeekerHttp.postJson("/server_info", request,
+					ServerInfoResponse.class);
+			}catch(IOException e)
+			{
+				throw new RuntimeException(e);
+			}
+		});
+	}
+	
+	private void handleServerInfoResponse(ServerInfoResponse response)
+	{
+		client.execute(() -> {
+			if(state == GetPlayersState.CANCELLED)
+				return;
+			
+			if(response.isError())
+			{
+				state = GetPlayersState.ERROR;
+				lastError = response.getError();
+			}else
+			{
+				state = GetPlayersState.DONE;
+				serverInfo = response;
+			}
+			
+			serverAddressBox.active = true;
+			getInfoButton.setMessage(Text.literal("Get Server Info"));
+		});
+	}
+	
+	private Void handleServerInfoError(Throwable throwable)
+	{
+		client.execute(() -> {
+			if(state == GetPlayersState.CANCELLED)
+				return;
+			
+			state = GetPlayersState.ERROR;
+			lastError = throwable.getMessage();
+			if(lastError == null || lastError.isEmpty())
+				lastError = "Network error occurred";
+			
+			serverAddressBox.active = true;
+			getInfoButton.setMessage(Text.literal("Get Server Info"));
+		});
+		return null;
+	}
+	
+	@Override
+	public void tick()
+	{
+		if(isServerInfoMode && getInfoButton != null)
+			getInfoButton.active = !serverAddressBox.getText().trim().isEmpty();
+	}
+	
+	@Override
+	public boolean keyPressed(KeyInput context)
+	{
+		if(isServerInfoMode && context.key() == GLFW.GLFW_KEY_ENTER
+			&& getInfoButton.active)
+		{
+			getInfoButton.onPress(context);
+			return true;
+		}
+		
+		if(!isServerInfoMode)
+		{
+			switch(context.key())
+			{
+				case GLFW.GLFW_KEY_UP:
+				scrollUp();
+				return true;
+				case GLFW.GLFW_KEY_DOWN:
+				scrollDown();
+				return true;
+				case GLFW.GLFW_KEY_PAGE_UP:
+				scroll = Math.max(0, scroll - SERVERS_PER_PAGE);
+				return true;
+				case GLFW.GLFW_KEY_PAGE_DOWN:
+				int maxScroll = Math.max(0, servers.size() - SERVERS_PER_PAGE);
+				scroll = Math.min(maxScroll, scroll + SERVERS_PER_PAGE);
+				return true;
+			}
+		}
+		
+		return super.keyPressed(context);
+	}
+	
+	@Override
+	public boolean mouseClicked(Click context, boolean doubleClick)
+	{
+		if(context.button() == GLFW.GLFW_MOUSE_BUTTON_4)
+		{
+			close();
+			return true;
+		}
+		
+		return super.mouseClicked(context, doubleClick);
+	}
+	
+	@Override
+	public void render(DrawContext context, int mouseX, int mouseY,
+		float partialTicks)
+	{
+		if(isServerInfoMode)
+		{
+			// Server info mode
+			context.drawCenteredTextWithShadow(textRenderer, "Get Server Info",
+				width / 2, 20, Colors.WHITE);
+			context.drawCenteredTextWithShadow(textRenderer,
+				"Get detailed information about any Minecraft server",
+				width / 2, 35, Colors.LIGHT_GRAY);
+			
+			context.drawTextWithShadow(textRenderer, "Server address:",
+				width / 2 - 100, height / 4 + 24, Colors.LIGHT_GRAY);
+			serverAddressBox.render(context, mouseX, mouseY, partialTicks);
+			
+			if(state != null)
+			{
+				context.drawCenteredTextWithShadow(textRenderer,
+					state.toString(), width / 2, height / 4 + 90,
+					Colors.LIGHT_GRAY);
+			}
+			
+			if(state == GetPlayersState.DONE && serverInfo != null)
+			{
+				renderServerInfo(context);
+			}else if(state == GetPlayersState.ERROR && lastError != null)
+			{
+				context.drawCenteredTextWithShadow(textRenderer,
+					"Error: " + lastError, width / 2, height / 4 + 100,
+					Colors.RED);
+			}
+		}else
+		{
+			// Player search results mode
+			context.drawCenteredTextWithShadow(textRenderer,
+				"Player Server History", width / 2, 20, Colors.WHITE);
+			context.drawCenteredTextWithShadow(
+				textRenderer, "Servers where the player has been seen ("
+					+ servers.size() + " total)",
+				width / 2, 35, Colors.LIGHT_GRAY);
+			
+			if(servers.isEmpty())
+			{
+				context.drawCenteredTextWithShadow(textRenderer,
+					"No server history available", width / 2, height / 2,
+					Colors.YELLOW);
+			}else
+			{
+				renderPlayerServerList(context);
+			}
+		}
+		
+		for(Drawable drawable : drawables)
+			drawable.render(context, mouseX, mouseY, partialTicks);
+	}
+	
+	private void renderServerInfo(DrawContext context)
+	{
+		int startY = height / 4 + 110;
+		
+		// Basic server info
+		context.drawTextWithShadow(textRenderer,
+			"Cracked: " + (serverInfo.isCracked() ? "Yes" : "No"),
+			width / 2 - 200, startY, Colors.LIGHT_GRAY);
+		
+		context.drawTextWithShadow(textRenderer,
+			"Players: " + serverInfo.getOnlinePlayers() + "/"
+				+ serverInfo.getMaxPlayers(),
+			width / 2 - 200, startY + 15, Colors.LIGHT_GRAY);
+		
+		context.drawTextWithShadow(textRenderer,
+			"Version: " + serverInfo.getVersion() + " (Protocol "
+				+ serverInfo.getProtocol() + ")",
+			width / 2 - 200, startY + 30, Colors.LIGHT_GRAY);
+		
+		String lastSeen = formatLastSeen(serverInfo.getLastSeen());
+		context.drawTextWithShadow(textRenderer, "Last Seen: " + lastSeen,
+			width / 2 - 200, startY + 45, Colors.LIGHT_GRAY);
+		
+		// Description
+		if(serverInfo.getDescription() != null
+			&& !serverInfo.getDescription().trim().isEmpty())
+		{
+			String desc =
+				serverInfo.getDescription().replaceAll("§.", "").trim();
+			context.drawTextWithShadow(textRenderer, "Description:",
+				width / 2 - 200, startY + 65, Colors.LIGHT_GRAY);
+			
+			// Word wrap description
+			String[] words = desc.split(" ");
+			StringBuilder line = new StringBuilder();
+			int lineY = startY + 80;
+			
+			for(String word : words)
+			{
+				if(textRenderer.getWidth(line + word + " ") > 380)
+				{
+					context.drawTextWithShadow(textRenderer,
+						line.toString().trim(), width / 2 - 200, lineY,
+						Colors.GRAY);
+					line = new StringBuilder(word + " ");
+					lineY += 12;
+				}else
+				{
+					line.append(word).append(" ");
+				}
+			}
+			if(line.length() > 0)
+			{
+				context.drawTextWithShadow(textRenderer, line.toString().trim(),
+					width / 2 - 200, lineY, Colors.GRAY);
+			}
+		}
+		
+		// Player list if available
+		if(!serverInfo.getPlayers().isEmpty())
+		{
+			int playerY = startY + 140;
+			context.drawTextWithShadow(textRenderer, "Recent Players:",
+				width / 2 - 200, playerY, Colors.LIGHT_GRAY);
+			
+			int playerCount = Math.min(10, serverInfo.getPlayers().size());
+			for(int i = 0; i < playerCount; i++)
+			{
+				ServerInfoResponse.Player player =
+					serverInfo.getPlayers().get(i);
+				String playerLastSeen = formatLastSeen(player.getLastSeen());
+				context.drawTextWithShadow(textRenderer,
+					"• " + player.getName() + " (" + playerLastSeen + ")",
+					width / 2 - 200, playerY + 15 + (i * 12), Colors.GRAY);
+			}
+			
+			if(serverInfo.getPlayers().size() > 10)
+			{
+				context.drawTextWithShadow(textRenderer,
+					"... and " + (serverInfo.getPlayers().size() - 10)
+						+ " more",
+					width / 2 - 200, playerY + 15 + (10 * 12), Colors.GRAY);
+			}
+		}
+	}
+	
+	private void renderPlayerServerList(DrawContext context)
+	{
+		// Draw server list
+		int startY = 60;
+		int endIndex = Math.min(servers.size(), scroll + SERVERS_PER_PAGE);
+		
+		for(int i = scroll; i < endIndex; i++)
+		{
+			WhereisResponse.PlayerServerEntry server = servers.get(i);
+			int yPos = startY + (i - scroll) * 25;
+			
+			// Server address
+			String address = server.getAddress();
+			context.drawTextWithShadow(textRenderer, address, width / 2 - 200,
+				yPos, Colors.LIGHT_GRAY);
+			
+			// Description (truncated)
+			String desc = server.getDescription();
+			if(desc != null && !desc.trim().isEmpty())
+			{
+				desc = desc.replaceAll("§.", "").trim();
+				if(desc.length() > 40)
+					desc = desc.substring(0, 40) + "...";
+				context.drawTextWithShadow(textRenderer, desc, width / 2 - 200,
+					yPos + 10, Colors.GRAY);
+			}
+			
+			// Player count and version
+			String info = server.getOnlinePlayers() + "/"
+				+ server.getMaxPlayers() + " | " + server.getVersion();
+			if(server.isCracked())
+				info += " | Cracked";
+			context.drawTextWithShadow(textRenderer, info, width / 2 + 20, yPos,
+				Colors.LIGHT_GRAY);
+			
+			// Last seen
+			String lastSeen = formatLastSeen(server.getLastSeen());
+			context.drawTextWithShadow(textRenderer, "Last: " + lastSeen,
+				width / 2 + 20, yPos + 10, Colors.GRAY);
+		}
+		
+		// Draw scroll indicators
+		if(servers.size() > SERVERS_PER_PAGE)
+		{
+			int totalPages =
+				(servers.size() + SERVERS_PER_PAGE - 1) / SERVERS_PER_PAGE;
+			int currentPage = (scroll / SERVERS_PER_PAGE) + 1;
+			context.drawCenteredTextWithShadow(textRenderer,
+				"Page " + currentPage + " / " + totalPages, width / 2,
+				height - 60, Colors.LIGHT_GRAY);
+		}
+	}
+	
+	private String formatLastSeen(long lastSeen)
+	{
+		try
+		{
+			return DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT)
+				.format(Instant.ofEpochSecond(lastSeen)
+					.atZone(ZoneId.systemDefault()).toLocalDateTime());
+		}catch(Exception e)
+		{
+			return "Unknown";
+		}
+	}
+	
+	@Override
+	public void close()
+	{
+		client.setScreen(prevScreen);
+	}
+	
+	enum GetPlayersState
+	{
+		NOT_RUNNING(""),
+		SEARCHING("\u00a72Getting server info..."),
+		CANCELLED("\u00a74Cancelled!"),
+		DONE("\u00a72Server info retrieved!"),
+		ERROR("\u00a74Failed to get server info!");
+		
+		private final String name;
+		
+		private GetPlayersState(String name)
+		{
+			this.name = name;
+		}
+		
+		public boolean isRunning()
+		{
+			return this == SEARCHING;
+		}
+		
+		@Override
+		public String toString()
+		{
+			return name;
+		}
+	}
+}